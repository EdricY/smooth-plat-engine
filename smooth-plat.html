<!DOCTYPE html>
<html>
<body>
<div id="loadmsg">Loading...</div>
<canvas id="canvas" width="960" height="720"></canvas>
<canvas hidden id="renderer" width="960" height="720"></canvas>
</body>
<img hidden id='c_map' src='collision-map.png' alt='img'>
<script>
// declarations
var canvas = document.getElementById('canvas')
var renderer = document.getElementById('renderer')
var c_map = document.getElementById('c_map')
 

var vis_ctx = canvas.getContext('2d')
var ctx = renderer.getContext('2d')

const backgroundColor = '#333'
const TILES = {
    '255,174,201,255': null,
    '255,255,255,255': 0,
    '0,0,0,255': 1
}
const GRAVITY = 1;
const FRICTION = .85;

let W = renderer.width
let H = renderer.height
var map_data
var gameInt
var lastTime = Date.now();
var keys = {};
var lastKeys = {};


var player = {
    x: 0,
    y: 0,
    vx: 0,
    vy: 0,
    w: 32,
	h: 64,
    ax: .6,
	jv: -18,
	mvx: 50,
	mvy: 20,
	jumps: 1,
    step_h: 16,
	midair: true,
    draw() {
        ctx.fillStyle = 'red';
        let f_x = Math.floor(this.x);
        let f_y = Math.floor(this.y);
        ctx.fillRect(f_x, f_y, this.w, this.h, this.color);
    },
    update() {
        this.vy += GRAVITY;
        if (keys[37] || keys[65]) { //left
            this.vx -= this.ax;
            if (this.vx < -this.maxv)
                this.vx = -this.maxv;
        }
        if (keys[39] || keys[68]) { //right
            this.vx += this.ax;
            if (this.vx > this.maxv)
                this.vx = this.maxv;
        }
        if (this.jumps && (keys[38] || keys[87]) && (!lastKeys[38] && !lastKeys[87])) { //up
            this.vy = -18;
        }
        if (this.vy >= 0) { //moving down
            let y_cls = findYCollisionDown(this.y, this.vy, this.x, this.w, this.h);
            if (y_cls == null) {
                this.y += this.vy;
                this.midair = true;
            } else { //landed on something
                this.vy = 0;
                this.y = y_cls.y;
                this.midair = false;
            }
        } else { //moving up
            let y_cls = findYCollisionUp(this.y, this.vy, this.x, this.w, this.h);
            this.midair = true;
            if (y_cls == null) {
                this.y += this.vy;
            } else { //hit your head
                this.vy = 0;
                this.y = y_cls.y;
                this.midair = false;
            }
        }
        if (this.vx > 0) { //moving right
            let x_cls = findXCollisionRight(this.x, this.vx, this.y, this.w, this.h);
            if (x_cls == null) this.x += this.vx;
            else { //hit wall
                let step_h = this.y + this.h - x_cls.y;
                if (step_h <= this.step_h) {
                    this.x = x_cls.x + 1;
                    this.y -= step_h; //not implemented: climbing more than 1 step
                } else {
                    this.vx = 0;
                    this.x = x_cls.x;
                }
            }
        } else if(this.vx < 0) { //moving left
            let x_cls = findXCollisionLeft(this.x, this.vx, this.y, this.w, this.h);
            if (x_cls == null) this.x += this.vx;
            else { //hit wall
                let step_h = this.y + this.h - x_cls.y;
                if (step_h <= this.step_h) {
                    this.x = x_cls.x - 1;
                    this.y -= step_h; //not implemented: climbing more than 1 step
                } else {
                    this.vx = 0;
                    this.x = x_cls.x;
                }
            }
        }
        this.vx *= FRICTION;
        if (Math.abs(this.vx) - .01 < 0) {
            this.vx = 0;
        }
    }
}

/* returns Point(x,y)
 * y: suggested relocation
 * x: collision position
 */
function findYCollisionDown(y, vy, x, width, height) {
    vy = Math.round(vy);
    if (vy <= 0) return null;
    y = Math.floor(y);
    x = Math.floor(x);
    let bottom = y + height
    for (let r = bottom; r < bottom + vy; r++) {
        if (r >= H) return new Point(x, H - height);
        for (let c = x; c < x + width; c++) {
            if (map_data[r][c] !== null) {
                return new Point(c, r - height);
            }
        }
    }
    return null;
}
function findYCollisionUp(y, vy, x, width, height) {
    vy = Math.round(vy);
    if (vy >= 0) return null;
    y = Math.floor(y);
    x = Math.floor(x);
    for (let r = y-1; r > y + vy-1; r--) {
        if (r <= 0) return new Point(x, 0);
        for (let c = x; c < x + width; c++) {
            if (map_data[r][c] == 1) {
                return new Point(c, r+1);
            }
        }
    }
    return null;
}

/* returns Point(x,y)
 * y: collision position
 * x: suggested relocation
 */
function findXCollisionRight(x, vx, y, width, height) {
    vx = Math.round(vx);
    if (vx <= 0) return null;
    x = Math.floor(x);
    y = Math.floor(y);
    let right = x + width;
    for (let c = right; c < right + vx; c++) {
        if (c >= W) return new Point(c - width, y); //right edge
        for (let r = y; r < y + height; r++) {
            if (map_data[r][c] == 1) {
                return new Point(c - width, r);
            }
        }
    }
    return null
}
function findXCollisionLeft(x, vx, y, width, height) {
    vx = Math.round(vx);
    if (vx >= 0) return null;
    x = Math.floor(x);
    y = Math.floor(y);
    for (let c = x-1; c > x + vx-1; c--) {
        if (c <= 0) return new Point(0, y); //left edge
        for (let r = y; r < y + height; r++) {
            if (map_data[r][c] == 1) {
                return new Point(c+1, r);
            }
        }
    }
    return null;
}


function init() {
    ctx.drawImage(c_map, 0, 0)
    map_data = getCanvasData();
    loadmsg.parentNode.removeChild(loadmsg);
    gameInt = setInterval(tick, 1);
    flushToCanvas()
}

function getCanvasData() {
    data = []
    raw_data = ctx.getImageData(0, 0, W, H).data
    for (let row = 0; row < H; row++) {
        data.push([])
        for (let col = 0; col < W; col++) {
            let pos = 4 * (col + row*W);
            let colorstr = raw_data.slice(pos, pos+4).toString()
            let tileid = TILES[colorstr]
            data[row].push(tileid);
        }
    }
    return data
}

setTimeout(init, 100);

function draw() {
    ctx.drawImage(c_map, 0, 0)
    player.draw()
    drawHUD()
}

function update() {
    player.update()
    lastKeys = JSON.parse(JSON.stringify(keys)); //deep copy

}

function tick() {
    if (Date.now() - lastTime > 10) {
        lastTime = Date.now();
        update();
    }
    // Particles.update();
    draw();
}


function flushToCanvas() {
    vis_ctx.drawImage(renderer, 0, 0); //flush to canvas
    requestAnimationFrame(flushToCanvas);
}

onkeydown = e => {
	let k = e.keyCode;
	keys[k] = true;
}

onkeyup = e => {
	let k = e.keyCode;
	keys[k] = false;
}

function drawHUD() {
	ctx.fillStyle = "yellow";
	ctx.font = "20px serif";
	ctx.textAlign = "right"
	properties = [
		'player.x',
		'player.y',
		'player.vx',
		'player.vy',
        'player.midair'
	]

	let spacing = 20;
	for (let i in properties){
		let s = properties[i];
		let displayStr = s;
		displayStr += ': ' + eval(s)
		ctx.fillText(displayStr, canvas.width - spacing, spacing + spacing*i)
	}
}

function Point(x, y) {
    this.x = x;
    this.y = y;
}
</script>