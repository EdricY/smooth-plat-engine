<!DOCTYPE html>
<html>
<head>
<script>
var loadedImgs = 0;
function imageLoaded() { loadedImgs++; }
</script>
</head>
<body>
<div id="loadmsg">Loading...</div>
<canvas id="canvas" width="960" height="720"></canvas>
<canvas hidden id="renderer" width="960" height="720"></canvas>
</body>
<img hidden id='c_map' src='collision-map.png' alt='img' onload="imageLoaded()">

<script src="frames.js"></script>
<script>
// declarations
var canvas = document.getElementById('canvas')
var renderer = document.getElementById('renderer')
var c_map = document.getElementById('c_map')
 

var vis_ctx = canvas.getContext('2d')
var ctx = renderer.getContext('2d')

const backgroundColor = '#333'
const TILES = {
    '255,174,201,255': null,
    '255,255,255,255': 0,
    '0,0,0,255': 1
}
const GRAVITY = 1;
const FRICTION = .85;

let W = renderer.width
let H = renderer.height
var map_data
var gameInt
var lastTime = Date.now();
var keys = {};
var lastKeys = {};


var player = {
    x: 40, // middle of player (right pixel)
    y: 0,  // bottom of player
    vx: 0,
    vy: 0,
    w: 32,
    hw: 32/2, //half width
	h: 64,
    ax: .6,
	jv: -18,
	mvx: 50,
	mvy: 20,
	jumps: 1,
    step_h: 16,
	midair: true,
    draw() {
        ctx.fillStyle = 'red';
        let top = this.y-this.h+1;
        let left = this.x -this.hw
        let f_x = Math.floor(left);
        let f_y = Math.floor(top);
        ctx.fillRect(f_x, f_y, this.w, this.h, this.color);
    },
    update() {
        this.vy += GRAVITY;
        if (keys[37] || keys[65]) { //left
            this.vx -= this.ax;
            if (this.vx < -this.maxv)
                this.vx = -this.maxv;
        }
        if (keys[39] || keys[68]) { //right
            this.vx += this.ax;
            if (this.vx > this.maxv)
                this.vx = this.maxv;
        }
        if (this.jumps && (keys[38] || keys[87]) && (!lastKeys[38] && !lastKeys[87])) { //up
            this.vy = -18;
        }
        let vy = Math.round(this.vy);

        //TODO: x-to-y ratio-driven slanted movement instead of L-shaped movement
        if (vy > 0) { //moving down
            for (let i = 0; i < vy; i++) {
                let x_cls = getCollisionDown(this.y, this.x, this.hw);
                if (x_cls == null) {
                    this.y++;
                    this.midair = true;
                } else { //landed on something
                    this.vy = 0;
                    this.midair = false;
                }
            }
        } else if (vy < 0) { //moving up
            this.midair = true;
            for (let i = 0; i > vy; i--) {
                let top = this.y-this.h+1;
                let x_cls = getCollisionUp(top, this.x, this.hw);
                if (x_cls == null) {
                    this.y--;
                } else { //hit your head
                    this.vy = 0;
                }
            }
        }
        
        let vx = Math.round(this.vx);
        if (vx > 0) { //moving right
            for (let i = 0; i < vx; i++) {
                let right = this.x+this.hw-1;
                let y_cls = getCollisionRight(right, this.y, this.h);
                if (y_cls == null) {
                    this.x++;
                } else { //hit wall
                    this.vx = 0;
                    let step_h = this.y-y_cls;
                    if (step_h < this.step_h) {
                        this.y = y_cls-1;
                        this.x++;
                        //not implemented: climbing more than 1 step
                    }
                }
            }
        } else if (vx < 0) { //moving left
            for (let i = 0; i > vx; i--) {
                let y_cls = getCollisionLeft(this.x-this.hw, this.y, this.h);
                if (y_cls == null) {
                    this.x--;
                } else { //hit wall
                    this.vx = 0;
                    let step_h = this.y-y_cls;
                    if (step_h < this.step_h) {
                        this.y = y_cls-1;
                        this.x--;
                        //not implemented: climbing more than 1 step
                    }
                }
            }
        }

        this.vx *= FRICTION;
        if (Math.abs(this.vx) - .01 < 0) {
            this.vx = 0;
        }
    }
}

// returns x pos of collision or null
function getCollisionDown(bottom, x, halfwidth) {
    let r = Math.round(bottom) + 1; //row below bottom
    if (r >= H) return x;           //screen bottom
    x = Math.round(x) - halfwidth;  //left
    for (let c = x; c < x + halfwidth*2; c++) {
        if (map_data[r][c] !== null) {
            return c;
        }
    }
    return null;
}

// returns x pos of collision or null
function getCollisionUp(top, x, halfwidth) {
    let r = Math.round(top) - 1;    //row above top
    if (r < 0) return x;            //screen top
    x = Math.round(x) - halfwidth;  //left
    for (let c = x; c < x + halfwidth*2; c++) {
        if (map_data[r][c] == 1) {
            return c;
        }
    }
    return null;
}

// returns y pos of collision or null
function getCollisionRight(right, y, height) {
    let c = Math.round(right) + 1;  //col after right
    if (c > W) return y;            //screen right
    y = Math.round(y);              //bottom
    for (let r = y-height+1; r <= y; r++) { //scan downward to find highest collision
        if (map_data[r][c] == 1) {
            return r;
        }
    }
    return null;
}

// returns y pos of collision or null
function getCollisionLeft(left, y, height) {
    let c = Math.round(left) - 1;   //col before left
    if (c < 0) return y;            //screen left
    y = Math.round(y);              //bottom
    for (let r = y-height+1; r <= y; r++) { //scan downward
        if (map_data[r][c] == 1) {
            return r;
        }
    }
    return null;
}

var loadInterval = setInterval(attemptInit, 500);
function attemptInit() {
    if (loadedImgs == 1) {
        ctx.drawImage(c_map, 0, 0)
        map_data = getCanvasData();
        loadmsg.parentNode.removeChild(loadmsg);
        gameInt = setInterval(tick, 1);
        flushToCanvas()
        clearInterval(loadInterval)
    }
}


function getCanvasData() {
    data = []
    raw_data = ctx.getImageData(0, 0, W, H).data
    for (let row = 0; row < H; row++) {
        data.push([])
        for (let col = 0; col < W; col++) {
            let pos = 4 * (col + row*W);
            let colorstr = raw_data.slice(pos, pos+4).toString()
            let tileid = TILES[colorstr]
            data[row].push(tileid);
        }
    }
    return data
}

function draw() {
    ctx.drawImage(c_map, 0, 0)
    player.draw()
    drawHUD()
}

function update() {
    player.update()
    lastKeys = JSON.parse(JSON.stringify(keys)); //deep copy

}

function tick() {
    if (Date.now() - lastTime > 10) {
        lastTime = Date.now();
        update();
    }
    // Particles.update();
    draw();
}


function flushToCanvas() {
    vis_ctx.drawImage(renderer, 0, 0); //flush to canvas
    requestAnimationFrame(flushToCanvas);
}

onkeydown = e => {
	let k = e.keyCode;
	keys[k] = true;
}

onkeyup = e => {
	let k = e.keyCode;
	keys[k] = false;
}

function drawHUD() {
	ctx.fillStyle = "yellow";
	ctx.font = "20px serif";
	ctx.textAlign = "right"
	properties = [
		'player.x',
		'player.y',
		'player.vx',
		'player.vy',
        'player.midair'
	]

	let spacing = 20;
	for (let i in properties){
		let s = properties[i];
		let displayStr = s;
		displayStr += ': ' + eval(s)
		ctx.fillText(displayStr, canvas.width - spacing, spacing + spacing*i)
	}
}

function Point(x, y) {
    this.x = x;
    this.y = y;
}
</script>
